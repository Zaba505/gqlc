---
sidebar: false
---

# The GraphQL Compiler

The GraphQL Compiler (gqlc) is used for scaffolding a GraphQL service as well
as generating documentation.

## Installing

`gqlc` can be installed by either downloading a [pre-built binary](https://github.com/gqlc/gqlc/releases) or by
building from [source](https://github.com/gqlc/gqlc).

## Usage

The simplest way to use `gqlc` is by first defining a schema in the GraphQL IDL.
For example,
```graphql
schema {
  query: Query,
  mutation: Mutation
}

type Query {
  "hero returns a character in an episode"
  hero(episode: Episode): Character
}

type Mutation {
  "addCharacter adds a new Character given their name and the episodes they appeared in."
  addCharacter(name: String!, episodes: [Episode!]!): Character
}

"Episode represents the episodes of the Star Wars saga."
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}

"Character represents a character in any episode of Star Wars."
type Character {
  name: String!
  appearsIn: [Episode]!
}
```

Now, that we have the schema for our GraphQL service it's time to start
implementing it. Typically, when implementing a GraphQL service you're thinking
in terms of the IDL, but not writing in it; instead, you're writing in whatever
language you have chosen to implement your service in. This is where gqlc comes
in handy, by providing you with a tool that can "compile", or translate, your IDL
definitions into source code definitions. To accomplish this, simply type the
following into your shell:

```bash
gqlc --doc_out . --js_out . schema.gql
```

`gqlc` will then generate two files:

*schema.js*: The JavaScript generator will output the scaffolding for implementing
a GraphQL service in JavaScript.
```javascript
var {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLEnumType,
  GraphQLList,
  GraphQLNonNull,
  GraphQLString
} = require('graphql');

var Schema = new GraphQLSchema({
  query: Query,
  mutation: Mutation
});

var EpisodeType = new GraphQLEnumType({
  name: 'Episode',
  values: {
    NEWHOPE: {
      value: 'NEWHOPE'
    },
    EMPIRE: {
      value: 'EMPIRE'
    },
    JEDI: {
      value: 'JEDI'
    }
  }
});

var QueryType = new GraphQLObjectType({
  name: 'Query',
  fields: {
    hero: {
      type: Character,
      args: {
        episode: {
          type: Episode
        }
      },
      resolve() { /* TODO */ }
    }
  }
});

var MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: {
    addCharacter: {
      type: Character,
      args: {
        name: {
          type: new GraphQLNonNull(GraphQLString)
        },
        episodes: {
          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(Episode)))
        }
      },
      resolve() { /* TODO */ }
    }
  }
});

var CharacterType = new GraphQLObjectType({
  name: 'Character',
  fields: {
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve() { /* TODO */ }
    },
    appearsIn: {
      type: new GraphQLNonNull(new GraphQLList(Episode)),
      resolve() { /* TODO */ }
    }
  }
});
```

*schema.md*: The documentation generator will output CommonMark documentation
for your service.
```markdown
# Documentation
*This was generated by gqlc.*

## Table of Contents
- [Schema](#Schema)
- [Objects](#Objects)
	* [Character](#Character)
	* [Mutation](#Mutation)
	* [Query](#Query)
- [Enums](#Enums)
	* [Episode](#Episode)

## Schema

*Root Operations*:
- query **([Query](#Query))**
- mutation **([Mutation](#Mutation))**

## Objects

### Character
Character represents a character in any episode of Star Wars.

*Fields*:
- name **(String!)**
- appearsIn **([[Episode](#Episode)]!)**

### Mutation

*Fields*:
- addCharacter **([Character](#Character))**

	  addCharacter adds a new Character
	*Args*:
	- name **(String!)**
	- episodes **([[Episode](#Episode)!]!)**

### Query

*Fields*:
- hero **([Character](#Character))**

	hero returns a character in an episode

	*Args*:
	- episode **([Episode](#Episode))**

## Enums

### Episode
Episode represents the episodes of the Star Wars saga.

*Values*:
- NEWHOPE
- EMPIRE
- JEDI
```

Now, all you have to do is fill in the resolvers and plug it into an http
endpoint. All generators and the compiler, itself, support options to tweak the
output.

## Supported Generators
Currently supported generators are:

* **Documentation** - generate [CommonMark](https://commonmark.org) documentation
* **Go** - generate [Go](https://golang.org)
* **JavaScript** - generate [JavaScript](https://javascript.com)
* **Plugin** - generate by running an external binary
